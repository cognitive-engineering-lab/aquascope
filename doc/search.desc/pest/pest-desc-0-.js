searchState.loadedDescShard("pest", 0, "pest. The Elegant Parser\nprevents implicit whitespace: inside an atomic rule, the …\nThe current atomicity of a <code>ParserState</code>.\nfrom the bottom to the top of the stack\nThe same as atomic, but inner tokens are produced as …\nThe ending <code>Position</code> of a matched <code>Rule</code>\nLine iterator for Spans, created by <code>Span::lines()</code>.\nLine iterator for Spans, created by <code>Span::lines_span()</code>.\nThe current lookahead status of a <code>ParserState</code>.\nMatch direction for the stack. Used in <code>PEEK[a..b]</code>/…\nThe negative predicate, written as an exclamation mark !, …\nimplicit whitespace is enabled\nNo lookahead (i.e. it will consume input).\nType alias to simplify specifying the return value of …\nA trait with a single method that parses strings.\nThe complete state of a <code>Parser</code>.\nA cursor position in a <code>&amp;str</code> which provides useful methods …\nThe positive predicate, written as an ampersand &amp;, …\nA trait which parser rules must implement.\nA span over a <code>&amp;str</code>. It is created from either two <code>Position</code>s…\nImplementation of a <code>Stack</code> which maintains popped elements …\nThe starting <code>Position</code> of a matched <code>Rule</code>\nA token generated by a <code>Parser</code>.\nfrom the top to the bottom of the stack\nCaptures a slice from the <code>&amp;str</code> defined by the <code>Span</code>.\nTransformation which stops <code>Token</code>s from being generated …\nReturns the current atomicity of the <code>ParserState</code>.\nThe parsing after the last snapshot was successful so …\nReturns the <code>Span</code>’s end byte position as a <code>usize</code>.\nAttempts to match the end of the input. Returns <code>Ok</code> with …\nReturns the <code>Span</code>’s end <code>Position</code>.\nTypes for different kinds of parsing failures.\nTesting tool that compares produced errors.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>Position</code> at the start of a <code>&amp;str</code>.\nAttempts to create a new span based on a sub-range.\nReturns the input string of the <code>Span</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the stack is currently empty.\nTypes and iterators for parser output.\nReturns the size of the stack\nReturns the line and column number of this <code>Position</code>.\nReturns the entire line of the input that contains this …\nIterates over all lines (partially) covered by this span. …\nIterates over all lines (partially) covered by this span. …\nStarts a lookahead transformation provided by <code>f</code> from the …\nAttempts to match a single character based on a filter …\nAttempts to case-insensitively match the given string. …\nAttempts to match a single character from the given range. …\nAttempts to match the given string. Returns <code>Ok</code> with the …\nMerges two spans into one.\nAllocates a fresh <code>ParserState</code> object to the heap and …\nAttempts to create a new <code>Position</code> at the given position. …\nAttempts to create a new span. Will return <code>None</code> if …\nCreates a new <code>Stack</code>.\nOptionally applies the transformation provided by <code>f</code> from …\nParses a <code>&amp;str</code> starting from <code>rule</code>.\nTesting tool that compares produced tokens.\nReturns the top-most <code>&amp;T</code> in the <code>Stack</code>.\nPops the top-most <code>T</code> from the <code>Stack</code>.\nReturns the byte position of this <code>Position</code> as a <code>usize</code>.\nReturns a reference to the current <code>Position</code> of the …\nConstructs useful in prefix, postfix, and infix operator …\nConstructs useful in infix operator parsing with the …\nPushes a <code>T</code> onto the <code>Stack</code>.\nRepeatedly applies the transformation provided by <code>f</code> from …\nRewinds the <code>Stack</code> to the most recent <code>snapshot()</code>. If no …\nRestores the original state of the <code>ParserState</code> when <code>f</code> …\nWrapper needed to generate tokens. This will associate the …\nStarts a sequence of transformations provided by <code>f</code> from …\nSets the maximum call limit for the parser state to …\nAttempts to skip <code>n</code> characters forward. Returns <code>Ok</code> with the …\nAttempts to skip forward until one of the given strings is …\nTakes a snapshot of the current <code>Stack</code>.\nCreates a <code>Span</code> from two <code>Position</code>s.\nSplits the <code>Span</code> into a pair of <code>Position</code>s.\nDrops the top of the stack. Returns <code>Ok(Box&lt;ParserState&gt;)</code> …\nMatches the full state of the stack.\nMatches part of the state of the stack.\nMatches the full state of the stack. This method will …\nPeeks the top of the stack and attempts to match the …\nPops the top of the stack and attempts to match the …\nEvaluates the result of closure <code>f</code> and pushes the span of …\nReturns the <code>Span</code>’s start byte position as a <code>usize</code>.\nAttempts to match the start of the input. Returns <code>Ok</code> with …\nReturns the <code>Span</code>’s start <code>Position</code>.\nCreates a <code>ParserState</code> from a <code>&amp;str</code>, supplying it to a …\nTag current node\nstarting position\nending position\nmatched rule\nmatched rule\nCustom error with a message\nParse-related error type.\nDifferent kinds of parsing errors.\nWhere an <code>Error</code> has occurred.\nLine/column where an <code>Error</code> has occurred.\nGenerated parsing error with expected and unexpected <code>Rule</code>s\n<code>Error</code> was created by <code>Error::new_from_pos</code>\nLine/column pair if <code>Error</code> was created by …\n<code>Error</code> was created by <code>Error::new_from_span</code>\nLine/column pairs if <code>Error</code> was created by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the line that the error is on.\nLine/column within the input string\nLocation within the input string\nReturns the error message for <code>ErrorVariant</code>\nCreates <code>Error</code> from <code>ErrorVariant</code> and <code>Position</code>.\nCreates <code>Error</code> from <code>ErrorVariant</code> and <code>Span</code>.\nReturns the path set using <code>Error::with_path()</code>.\nRenames all <code>Rule</code>s if this is a <code>ParsingError</code>. It does …\nVariant of the error\nReturns <code>Error</code> variant with <code>path</code> which is shown when …\nShort explanation\nNegative attempts\nPositive attempts\nAn iterator over <code>Pair</code>s. It is created by <code>Pairs::flatten</code>.\nA matching pair of <code>Token</code>s and everything between them.\nAn iterator over <code>Pair</code>s. It is created by <code>pest::state</code> and …\nAn iterator over <code>Token</code>s. It is created by <code>Pair::tokens</code> and …\nGet current node tag\nReturns the <code>Rule</code> of the <code>Pair</code>.\nReturns the <code>Span</code> defined by the <code>Pair</code>, <strong>without</strong> consuming it.\nCaptures a slice from the <code>&amp;str</code> defined by the token <code>Pair</code>.\nCaptures a slice from the <code>&amp;str</code> defined by the starting …\nCaptures inner token <code>Pair</code>s and concatenates resulting <code>&amp;str</code>…\nFinds the first pair that has its node or branch tagged …\nReturns the iterator over pairs that have their node or …\nFlattens the <code>Pairs</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the input string of the <code>Pair</code>.\nReturns the input string of <code>Pairs</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner <code>Pairs</code> between the <code>Pair</code>, consuming it.\nReturns the <code>Span</code> defined by the <code>Pair</code>, consuming it.\nReturns the <code>line</code>, <code>col</code> of this pair start.\nPeek at the first inner <code>Pair</code> without changing the position …\nCreate a new <code>Pairs</code> iterator containing just the single <code>Pair</code>…\nReturns the <code>Tokens</code> for these pairs.\nReturns the <code>Tokens</code> for the <code>Pair</code>.\nReturns the <code>Tokens</code> for the <code>Pairs</code>.\nAssociativity of an infix binary operator, used by …\nLeft operator associativity. Evaluate expressions from …\nAn operator that corresponds to a rule.\nStruct containing operators and precedences, which can …\nProduct of calling <code>map_primary</code> on <code>PrattParser</code>, defines how …\nRight operator associativity. Evaluate expressions from …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDefines <code>rule</code> as an infix binary operator with …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps infix operators with a closure <code>infix</code>.\nMaps postfix operators with closure <code>postfix</code>.\nMaps prefix operators with closure <code>prefix</code>.\nMaps primary expressions with a closure <code>primary</code>.\nInstantiate a new <code>PrattParser</code>.\nAdd <code>op</code> to <code>PrattParser</code>.\nThe last method to call on the provided pairs to execute …\nDefines <code>rule</code> as a postfix unary operator.\nDefines <code>rule</code> as a prefix unary operator.\nAssociativity of an <code>Operator</code>.\nLeft <code>Operator</code> associativity\nInfix operator used in <code>PrecClimber</code>.\nList of operators and precedences, which can perform …\nRight <code>Operator</code> associativity\nPerforms the precedence climbing algorithm on the <code>pairs</code> in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>Operator</code> from a <code>Rule</code> and <code>Assoc</code>.\nCreates a new <code>PrecClimber</code> from the <code>Operator</code>s contained in …")