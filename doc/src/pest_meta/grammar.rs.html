<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/Users/gavinleroy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pest_meta-2.7.3/src/grammar.rs`."><title>grammar.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="pest_meta" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0-dev" data-channel="nightly" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../src-files.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/pest-parser/pest/master/pest-logo.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
</pre></div><pre class="rust"><code><span class="kw">pub struct </span>PestParser;
# [doc = <span class="string">"Pest meta-grammar\n\n# Warning: Semantic Versioning\nThere may be non-breaking changes to the meta-grammar\nbetween minor versions. Those non-breaking changes, however,\nmay translate into semver-breaking changes due to the additional variants\nadded to the `Rule` enum. This is a known issue and will be fixed in the\nfuture (e.g. by increasing MSRV and non_exhaustive annotations)."</span>] # [allow (dead_code , non_camel_case_types , clippy :: upper_case_acronyms)] # [derive (Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] <span class="kw">pub enum </span>Rule { EOI , # [doc = <span class="string">"The top-level rule of a grammar."</span>] r#grammar_rules , # [doc = <span class="string">"A rule of a grammar."</span>] r#grammar_rule , # [doc = <span class="string">"Assignment operator."</span>] r#assignment_operator , # [doc = <span class="string">"Opening brace for a rule."</span>] r#opening_brace , # [doc = <span class="string">"Closing brace for a rule."</span>] r#closing_brace , # [doc = <span class="string">"Opening parenthesis for a branch, PUSH, etc."</span>] r#opening_paren , # [doc = <span class="string">"Closing parenthesis for a branch, PUSH, etc."</span>] r#closing_paren , # [doc = <span class="string">"Opening bracket for PEEK (slice inside)."</span>] r#opening_brack , # [doc = <span class="string">"Closing bracket for PEEK (slice inside)."</span>] r#closing_brack , # [doc = <span class="string">"A rule modifier."</span>] r#modifier , # [doc = <span class="string">"Silent rule prefix."</span>] r#silent_modifier , # [doc = <span class="string">"Atomic rule prefix."</span>] r#atomic_modifier , # [doc = <span class="string">"Compound atomic rule prefix."</span>] r#compound_atomic_modifier , # [doc = <span class="string">"Non-atomic rule prefix."</span>] r#non_atomic_modifier , # [doc = <span class="string">"A tag label."</span>] r#tag_id , # [doc = <span class="string">"For assigning labels to nodes."</span>] r#node_tag , # [doc = <span class="string">"A rule expression."</span>] r#expression , # [doc = <span class="string">"A rule term."</span>] r#term , # [doc = <span class="string">"A rule node (inside terms)."</span>] r#node , # [doc = <span class="string">"A terminal expression."</span>] r#terminal , # [doc = <span class="string">"Possible predicates for a rule."</span>] r#prefix_operator , # [doc = <span class="string">"Branches or sequences."</span>] r#infix_operator , # [doc = <span class="string">"Possible modifiers for a rule."</span>] r#postfix_operator , # [doc = <span class="string">"A positive predicate."</span>] r#positive_predicate_operator , # [doc = <span class="string">"A negative predicate."</span>] r#negative_predicate_operator , # [doc = <span class="string">"A sequence operator."</span>] r#sequence_operator , # [doc = <span class="string">"A choice operator."</span>] r#choice_operator , # [doc = <span class="string">"An optional operator."</span>] r#optional_operator , # [doc = <span class="string">"A repeat operator."</span>] r#repeat_operator , # [doc = <span class="string">"A repeat at least once operator."</span>] r#repeat_once_operator , # [doc = <span class="string">"A repeat exact times."</span>] r#repeat_exact , # [doc = <span class="string">"A repeat at least times."</span>] r#repeat_min , # [doc = <span class="string">"A repeat at most times."</span>] r#repeat_max , # [doc = <span class="string">"A repeat in a range."</span>] r#repeat_min_max , # [doc = <span class="string">"A number."</span>] r#number , # [doc = <span class="string">"An integer number (positive or negative)."</span>] r#integer , # [doc = <span class="string">"A comma terminal."</span>] r#comma , # [doc = <span class="string">"A PUSH expression."</span>] r#_push , # [doc = <span class="string">"A PEEK expression."</span>] r#peek_slice , # [doc = <span class="string">"An identifier."</span>] r#identifier , # [doc = <span class="string">"An alpha character."</span>] r#alpha , # [doc = <span class="string">"An alphanumeric character."</span>] r#alpha_num , # [doc = <span class="string">"A string."</span>] r#string , # [doc = <span class="string">"An insensitive string."</span>] r#insensitive_string , # [doc = <span class="string">"A character range."</span>] r#range , # [doc = <span class="string">"A single quoted character"</span>] r#character , # [doc = <span class="string">"A quoted string."</span>] r#inner_str , # [doc = <span class="string">"An escaped or any character."</span>] r#inner_chr , # [doc = <span class="string">"An escape sequence."</span>] r#escape , # [doc = <span class="string">"A hexadecimal code."</span>] r#code , # [doc = <span class="string">"A unicode code."</span>] r#unicode , # [doc = <span class="string">"A hexadecimal digit."</span>] r#hex_digit , # [doc = <span class="string">"A double quote."</span>] r#quote , # [doc = <span class="string">"A single quote."</span>] r#single_quote , # [doc = <span class="string">"A range operator."</span>] r#range_operator , # [doc = <span class="string">"A newline character."</span>] r#newline , # [doc = <span class="string">"A whitespace character."</span>] r#WHITESPACE , # [doc = <span class="string">"A single line comment."</span>] r#line_comment , # [doc = <span class="string">"A multi-line comment."</span>] r#block_comment , # [doc = <span class="string">"A grammar comment."</span>] r#COMMENT , # [doc = <span class="string">"A space character."</span>] r#space , # [doc = <span class="string">"A top-level comment."</span>] r#grammar_doc , # [doc = <span class="string">"A rule comment."</span>] r#line_doc , # [doc = <span class="string">"A comment content."</span>] r#inner_doc } # [allow (clippy :: all)] <span class="kw">impl </span>:: pest :: Parser &lt; Rule &gt; <span class="kw">for </span>PestParser { <span class="kw">fn </span>parse &lt; <span class="lifetime">'i </span>&gt; (rule : Rule , input : &amp; <span class="lifetime">'i </span>str) -&gt; :: std :: result :: <span class="prelude-ty">Result </span>&lt; :: pest :: iterators :: Pairs &lt; <span class="lifetime">'i </span>, Rule &gt; , :: pest :: error :: Error &lt; Rule &gt; &gt; { <span class="kw">mod </span>rules { # ! [allow (clippy :: upper_case_acronyms)] <span class="kw">pub mod </span>hidden { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>skip (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="kw">if </span>state . atomicity () == :: pest :: Atomicity :: NonAtomic { state . sequence (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: visible :: COMMENT (state) . and_then (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) }) }) }) }) }) } <span class="kw">else </span>{ <span class="prelude-val">Ok </span>(state) } } } <span class="kw">pub mod </span>visible { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#grammar_rules (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { <span class="self">self </span>:: r#SOI (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#grammar_doc (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#grammar_doc (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#grammar_rule (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#grammar_rule (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#EOI (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#grammar_rule (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#grammar_rule , | state | { state . sequence (| state | { <span class="self">self </span>:: r#identifier (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#assignment_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#modifier (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#opening_brace (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#line_doc (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#assignment_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#assignment_operator , | state | { state . match_string (<span class="string">"="</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#opening_brace (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#opening_brace , | state | { state . match_string (<span class="string">"{"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#closing_brace (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#closing_brace , | state | { state . match_string (<span class="string">"}"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#opening_paren (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#opening_paren , | state | { state . match_string (<span class="string">"("</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#closing_paren (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#closing_paren , | state | { state . match_string (<span class="string">")"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#opening_brack (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#opening_brack , | state | { state . match_string (<span class="string">"["</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#closing_brack (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#closing_brack , | state | { state . match_string (<span class="string">"]"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#silent_modifier (state) . or_else (| state | { <span class="self">self </span>:: r#atomic_modifier (state) }) . or_else (| state | { <span class="self">self </span>:: r#compound_atomic_modifier (state) }) . or_else (| state | { <span class="self">self </span>:: r#non_atomic_modifier (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#silent_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#silent_modifier , | state | { state . match_string (<span class="string">"_"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#atomic_modifier , | state | { state . match_string (<span class="string">"@"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#compound_atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#compound_atomic_modifier , | state | { state . match_string (<span class="string">"$"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#non_atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#non_atomic_modifier , | state | { state . match_string (<span class="string">"!"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#tag_id (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#tag_id , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">"#"</span>) . and_then (| state | { state . match_string (<span class="string">"_"</span>) . or_else (| state | { <span class="self">self </span>:: r#alpha (state) }) }) . and_then (| state | { state . repeat (| state | { state . match_string (<span class="string">"_"</span>) . or_else (| state | { <span class="self">self </span>:: r#alpha_num (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#node_tag (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { <span class="self">self </span>:: r#tag_id (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#assignment_operator (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#expression (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#expression , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#choice_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#term (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { <span class="self">self </span>:: r#infix_operator (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#term (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#infix_operator (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#term (state) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#term (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#term , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#node_tag (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#prefix_operator (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#prefix_operator (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#node (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#postfix_operator (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#postfix_operator (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#node (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { <span class="self">self </span>:: r#opening_paren (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_paren (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#terminal (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#terminal (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#_push (state) . or_else (| state | { <span class="self">self </span>:: r#peek_slice (state) }) . or_else (| state | { <span class="self">self </span>:: r#identifier (state) }) . or_else (| state | { <span class="self">self </span>:: r#string (state) }) . or_else (| state | { <span class="self">self </span>:: r#insensitive_string (state) }) . or_else (| state | { <span class="self">self </span>:: r#range (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#prefix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#positive_predicate_operator (state) . or_else (| state | { <span class="self">self </span>:: r#negative_predicate_operator (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#infix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#sequence_operator (state) . or_else (| state | { <span class="self">self </span>:: r#choice_operator (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#postfix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#optional_operator (state) . or_else (| state | { <span class="self">self </span>:: r#repeat_operator (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_once_operator (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_exact (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_min (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_max (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_min_max (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#positive_predicate_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#positive_predicate_operator , | state | { state . match_string (<span class="string">"&amp;"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#negative_predicate_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#negative_predicate_operator , | state | { state . match_string (<span class="string">"!"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#sequence_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#sequence_operator , | state | { state . match_string (<span class="string">"~"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#choice_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#choice_operator , | state | { state . match_string (<span class="string">"|"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#optional_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#optional_operator , | state | { state . match_string (<span class="string">"?"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_operator , | state | { state . match_string (<span class="string">"*"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_once_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_once_operator , | state | { state . match_string (<span class="string">"+"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_exact (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_exact , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_min (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_min , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_max (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_max , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_min_max (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_min_max , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#number (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#number , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_range (<span class="string">'0' </span>.. <span class="string">'9'</span>) . and_then (| state | { state . repeat (| state | { state . match_range (<span class="string">'0' </span>.. <span class="string">'9'</span>) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#integer (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#integer , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: r#number (state) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">"-"</span>) . and_then (| state | { state . repeat (| state | { state . match_string (<span class="string">"0"</span>) }) }) . and_then (| state | { state . match_range (<span class="string">'1' </span>.. <span class="string">'9'</span>) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#number (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#comma (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#comma , | state | { state . match_string (<span class="string">","</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#_push (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#_push , | state | { state . sequence (| state | { state . match_string (<span class="string">"PUSH"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#opening_paren (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_paren (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#peek_slice (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#peek_slice , | state | { state . sequence (| state | { state . match_string (<span class="string">"PEEK"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#opening_brack (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#integer (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#range_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#integer (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brack (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#identifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#identifier , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">"PUSH"</span>) }) . and_then (| state | { state . match_string (<span class="string">"_"</span>) . or_else (| state | { <span class="self">self </span>:: r#alpha (state) }) }) . and_then (| state | { state . repeat (| state | { state . match_string (<span class="string">"_"</span>) . or_else (| state | { <span class="self">self </span>:: r#alpha_num (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#alpha (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">'a' </span>.. <span class="string">'z'</span>) . or_else (| state | { state . match_range (<span class="string">'A' </span>.. <span class="string">'Z'</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#alpha_num (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#alpha (state) . or_else (| state | { state . match_range (<span class="string">'0' </span>.. <span class="string">'9'</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#string , | state | { state . sequence (| state | { <span class="self">self </span>:: r#quote (state) . and_then (| state | { <span class="self">self </span>:: r#inner_str (state) }) . and_then (| state | { <span class="self">self </span>:: r#quote (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#insensitive_string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#insensitive_string , | state | { state . sequence (| state | { state . match_string (<span class="string">"^"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#string (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#range (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#range , | state | { state . sequence (| state | { <span class="self">self </span>:: r#character (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#range_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#character (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#character (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#character , | state | { state . sequence (| state | { <span class="self">self </span>:: r#single_quote (state) . and_then (| state | { <span class="self">self </span>:: r#inner_chr (state) }) . and_then (| state | { <span class="self">self </span>:: r#single_quote (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#inner_str (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#inner_str , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { <span class="kw">let </span>strings = [<span class="string">"\"" </span>, <span class="string">"\\"</span>] ; state . skip_until (&amp; strings) . and_then (| state | { state . optional (| state | { state . sequence (| state | { <span class="self">self </span>:: r#escape (state) . and_then (| state | { <span class="self">self </span>:: r#inner_str (state) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#inner_chr (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#inner_chr , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: r#escape (state) . or_else (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#escape (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#escape , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">"\\"</span>) . and_then (| state | { state . match_string (<span class="string">"\""</span>) . or_else (| state | { state . match_string (<span class="string">"\\"</span>) }) . or_else (| state | { state . match_string (<span class="string">"r"</span>) }) . or_else (| state | { state . match_string (<span class="string">"n"</span>) }) . or_else (| state | { state . match_string (<span class="string">"t"</span>) }) . or_else (| state | { state . match_string (<span class="string">"0"</span>) }) . or_else (| state | { state . match_string (<span class="string">"'"</span>) }) . or_else (| state | { <span class="self">self </span>:: r#code (state) }) . or_else (| state | { <span class="self">self </span>:: r#unicode (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#code (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#code , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">"x"</span>) . and_then (| state | { <span class="self">self </span>:: r#hex_digit (state) }) . and_then (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#unicode (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#unicode , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">"u"</span>) . and_then (| state | { <span class="self">self </span>:: r#opening_brace (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#hex_digit (state) . and_then (| state | { <span class="self">self </span>:: r#hex_digit (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) }) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#hex_digit (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#hex_digit , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_range (<span class="string">'0' </span>.. <span class="string">'9'</span>) . or_else (| state | { state . match_range (<span class="string">'a' </span>.. <span class="string">'f'</span>) }) . or_else (| state | { state . match_range (<span class="string">'A' </span>.. <span class="string">'F'</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#quote (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#quote , | state | { state . match_string (<span class="string">"\""</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#single_quote (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#single_quote , | state | { state . match_string (<span class="string">"'"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#range_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#range_operator , | state | { state . match_string (<span class="string">".."</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#newline (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . match_string (<span class="string">"\n"</span>) . or_else (| state | { state . match_string (<span class="string">"\r\n"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#WHITESPACE (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string (<span class="string">" "</span>) . or_else (| state | { state . match_string (<span class="string">"\t"</span>) }) . or_else (| state | { <span class="self">self </span>:: r#newline (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#line_comment (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { state . match_string (<span class="string">"//"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">"/"</span>) . or_else (| state | { state . match_string (<span class="string">"!"</span>) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#newline (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#newline (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#block_comment (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { state . match_string (<span class="string">"/*"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#block_comment (state) . or_else (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">"*/"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#block_comment (state) . or_else (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">"*/"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"*/"</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#COMMENT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: r#block_comment (state) . or_else (| state | { <span class="self">self </span>:: r#line_comment (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#space (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . match_string (<span class="string">" "</span>) . or_else (| state | { state . match_string (<span class="string">"\t"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#grammar_doc (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#grammar_doc , | state | { state . sequence (| state | { state . match_string (<span class="string">"//!"</span>) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#space (state) }) }) . and_then (| state | { <span class="self">self </span>:: r#inner_doc (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#line_doc (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#line_doc , | state | { state . sequence (| state | { state . match_string (<span class="string">"///"</span>) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#space (state) }) }) . and_then (| state | { <span class="self">self </span>:: r#inner_doc (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#inner_doc (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#inner_doc , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . repeat (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#newline (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) }) }) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ANY (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . skip (<span class="number">1</span>) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>EOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: EOI , | state | state . end_of_input ()) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>SOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . start_of_input () } } <span class="kw">pub use </span><span class="self">self </span>:: visible :: * ; } :: pest :: state (input , | state | { <span class="kw">match </span>rule { Rule :: r#grammar_rules =&gt; rules :: r#grammar_rules (state) , Rule :: r#grammar_rule =&gt; rules :: r#grammar_rule (state) , Rule :: r#assignment_operator =&gt; rules :: r#assignment_operator (state) , Rule :: r#opening_brace =&gt; rules :: r#opening_brace (state) , Rule :: r#closing_brace =&gt; rules :: r#closing_brace (state) , Rule :: r#opening_paren =&gt; rules :: r#opening_paren (state) , Rule :: r#closing_paren =&gt; rules :: r#closing_paren (state) , Rule :: r#opening_brack =&gt; rules :: r#opening_brack (state) , Rule :: r#closing_brack =&gt; rules :: r#closing_brack (state) , Rule :: r#modifier =&gt; rules :: r#modifier (state) , Rule :: r#silent_modifier =&gt; rules :: r#silent_modifier (state) , Rule :: r#atomic_modifier =&gt; rules :: r#atomic_modifier (state) , Rule :: r#compound_atomic_modifier =&gt; rules :: r#compound_atomic_modifier (state) , Rule :: r#non_atomic_modifier =&gt; rules :: r#non_atomic_modifier (state) , Rule :: r#tag_id =&gt; rules :: r#tag_id (state) , Rule :: r#node_tag =&gt; rules :: r#node_tag (state) , Rule :: r#expression =&gt; rules :: r#expression (state) , Rule :: r#term =&gt; rules :: r#term (state) , Rule :: r#node =&gt; rules :: r#node (state) , Rule :: r#terminal =&gt; rules :: r#terminal (state) , Rule :: r#prefix_operator =&gt; rules :: r#prefix_operator (state) , Rule :: r#infix_operator =&gt; rules :: r#infix_operator (state) , Rule :: r#postfix_operator =&gt; rules :: r#postfix_operator (state) , Rule :: r#positive_predicate_operator =&gt; rules :: r#positive_predicate_operator (state) , Rule :: r#negative_predicate_operator =&gt; rules :: r#negative_predicate_operator (state) , Rule :: r#sequence_operator =&gt; rules :: r#sequence_operator (state) , Rule :: r#choice_operator =&gt; rules :: r#choice_operator (state) , Rule :: r#optional_operator =&gt; rules :: r#optional_operator (state) , Rule :: r#repeat_operator =&gt; rules :: r#repeat_operator (state) , Rule :: r#repeat_once_operator =&gt; rules :: r#repeat_once_operator (state) , Rule :: r#repeat_exact =&gt; rules :: r#repeat_exact (state) , Rule :: r#repeat_min =&gt; rules :: r#repeat_min (state) , Rule :: r#repeat_max =&gt; rules :: r#repeat_max (state) , Rule :: r#repeat_min_max =&gt; rules :: r#repeat_min_max (state) , Rule :: r#number =&gt; rules :: r#number (state) , Rule :: r#integer =&gt; rules :: r#integer (state) , Rule :: r#comma =&gt; rules :: r#comma (state) , Rule :: r#_push =&gt; rules :: r#_push (state) , Rule :: r#peek_slice =&gt; rules :: r#peek_slice (state) , Rule :: r#identifier =&gt; rules :: r#identifier (state) , Rule :: r#alpha =&gt; rules :: r#alpha (state) , Rule :: r#alpha_num =&gt; rules :: r#alpha_num (state) , Rule :: r#string =&gt; rules :: r#string (state) , Rule :: r#insensitive_string =&gt; rules :: r#insensitive_string (state) , Rule :: r#range =&gt; rules :: r#range (state) , Rule :: r#character =&gt; rules :: r#character (state) , Rule :: r#inner_str =&gt; rules :: r#inner_str (state) , Rule :: r#inner_chr =&gt; rules :: r#inner_chr (state) , Rule :: r#escape =&gt; rules :: r#escape (state) , Rule :: r#code =&gt; rules :: r#code (state) , Rule :: r#unicode =&gt; rules :: r#unicode (state) , Rule :: r#hex_digit =&gt; rules :: r#hex_digit (state) , Rule :: r#quote =&gt; rules :: r#quote (state) , Rule :: r#single_quote =&gt; rules :: r#single_quote (state) , Rule :: r#range_operator =&gt; rules :: r#range_operator (state) , Rule :: r#newline =&gt; rules :: r#newline (state) , Rule :: r#WHITESPACE =&gt; rules :: r#WHITESPACE (state) , Rule :: r#line_comment =&gt; rules :: r#line_comment (state) , Rule :: r#block_comment =&gt; rules :: r#block_comment (state) , Rule :: r#COMMENT =&gt; rules :: r#COMMENT (state) , Rule :: r#space =&gt; rules :: r#space (state) , Rule :: r#grammar_doc =&gt; rules :: r#grammar_doc (state) , Rule :: r#line_doc =&gt; rules :: r#line_doc (state) , Rule :: r#inner_doc =&gt; rules :: r#inner_doc (state) , Rule :: EOI =&gt; rules :: EOI (state) } }) } }
</code></pre></div></section></main></body></html>